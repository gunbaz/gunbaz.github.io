<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimizasyon El Kitabı | Profesörün Notları</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Warm Sand (Sıcak Kum) -->
    <!-- Application Structure Plan: Sol tarafta sabit bir gezinme menüsü (masaüstü) ve üstte bir mobil menü (mobil) bulunan iki sütunlu bir SPA düzeni seçtim. Gezinme menüsü, el kitabının 6 ana bölümünü listeler. Bir bölüme tıklandığında, sayfa yeniden yüklenmez; bunun yerine, JavaScript ana içerik alanındaki mevcut bölümü gizler ve seçilen bölümü gösterir. Bu yapı, kullanıcının konular arasında hızla atlamasına olanak tanıyarak ve "içindekiler"i her zaman görünür kılarak "kolay keşif" hedefini karşılıyor. Bu, doğrusal bir rapordan çok daha kullanıcı dostudur. Ayrıca, kod blokları için "Göster/Gizle" düğmeleri ekleyerek, metni temiz tuttum ve kullanıcının teknik ayrıntılara kendi isteğiyle dalmasına izin verdim. -->
    <!-- Visualization & Content Choices: Bu rapordaki ana içerik metin, analojiler ve kod parçacıklarıdır. Standart grafikler (Bar, Line vb.) için uygun bir veri seti bulunmamaktadır. Bu nedenle, görselleştirme çabaları, bilginin en iyi şekilde sunulmasına odaklanmıştır:
1. İçerik (Metin/Anlatı) -> Amaç (Açıklama) -> Sunum (İyi biçimlendirilmiş metin paragrafları, `prose` sınıfı kullanılarak) -> Etkileşim (Gezinme yoluyla bölüm değiştirme).
2. İçerik (Örnek Görüntüler) -> Amaç (Analojiyi Görselleştirme) -> Sunum (Metin içeren yer tutucu görüntüler) -> Etkileşim (Yok).
3. İçerik (Python Kodları) -> Amaç (Teknik Uygulamayı Gösterme) -> Sunum (Karanlık tema `<pre><code>` bloğu) -> Etkileşim (Her kod bloğu için 'Göster/Gizle' düğmesi - Vanilla JS ile).
Bu seçimler, kullanıcının bunalmasını engeller ve metin ile kod arasında net bir ayrım sağlar. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Merriweather:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        h1, h2, h3, h4, .font-serif {
            font-family: 'Merriweather', serif;
        }
        .nav-link.nav-active {
            background-color: #d97706; /* amber-600 */
            color: white;
            font-weight: 600;
        }
        .nav-link.nav-active:hover {
            background-color: #b45309; /* amber-700 */
        }
        .code-container {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-stone-50 text-stone-800">

    <div class="flex min-h-screen">
        <!-- Mobil Menü Düğmesi -->
        <div class="md:hidden fixed top-0 left-0 right-0 bg-stone-100 p-4 z-20 shadow-md">
            <div class="flex justify-between items-center">
                <h2 class="text-xl font-serif text-amber-800">El Kitabı Menüsü</h2>
                <button id="mobile-menu-button" class="p-2 rounded-md text-stone-700 hover:bg-stone-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Mobil Menü İçeriği (Gizli) -->
        <nav id="mobile-menu" class="md:hidden fixed top-16 left-0 right-0 bg-stone-100 z-10 shadow-lg p-4 hidden">
            <ul class="space-y-2">
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors nav-active" data-target="bölüm1">Bölüm 1: Optimizasyona Giriş</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm2">Bölüm 2: Genetik Algoritma (GA)</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm3">Bölüm 3: GA - Seçilim</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm4">Bölüm 4: GA - Çaprazlama</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm5">Bölüm 5: Diferansiyel Evrim (DE)</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm6">Bölüm 6: Uygulama Örnekleri</a></li>
            </ul>
        </nav>
        
        <!-- Masaüstü Yan Gezinme Menüsü -->
        <nav class="w-72 flex-shrink-0 bg-stone-100 p-6 h-screen sticky top-0 overflow-y-auto hidden md:block">
            <h1 class="text-2xl font-serif text-amber-800 mb-2">Optimizasyon El Kitabı</h1>
            <p class="text-sm text-stone-600 mb-6">Profesörün Notları</p>
            <ul class="space-y-2">
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors nav-active" data-target="bölüm1">Bölüm 1: Optimizasyona Giriş</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm2">Bölüm 2: Genetik Algoritma (GA)</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm3">Bölüm 3: GA - Seçilim</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm4">Bölüm 4: GA - Çaprazlama</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm5">Bölüm 5: Diferansiyel Evrim (DE)</a></li>
                <li><a href="#" class="nav-link block p-3 rounded-lg hover:bg-stone-200 transition-colors" data-target="bölüm6">Bölüm 6: Uygulama Örnekleri</a></li>
            </ul>
        </nav>

        <!-- Ana İçerik Alanı -->
        <main class="flex-1 p-6 md:p-12 overflow-y-auto mt-16 md:mt-0">
            <div class="max-w-4xl mx-auto">
                
                <!-- BÖLÜM 1: GİRİŞ (Varsayılan olarak görünür) -->
                <section id="bölüm1" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700">
                    <p class="text-sm text-stone-500">Sevgili öğrencilerim, optimizasyon dersimizin bu özel "El Kitabı" bölümüne hepiniz hoş geldiniz. Ben, bu alanda 20 yılı aşkın süredir çalışan kıdemli bir profesörünüz olarak, sizlere en karmaşık mühendislik problemlerinin bile ne kadar basit ve zarif temellere dayandığını göstermek için buradayım.</p>
                    <p>Unutmayın, en karmaşık görünen dağ bile küçük adımlarla tırmanılır. Bizim görevimiz, bu adımların ne olduğunu öğrenmek. Bu el kitabında, doğadan ilham alan ve günümüzün en zorlu problemlerini (rota planlamadan ilaç tasarımına kadar) çözmek için kullanılan güçlü araçları, yani meta-sezgisel algoritmaları inceleyeceğiz.</p>
                    <p>Her konuyu, sıfırdan başlıyormuşuz gibi, bolca benzetme (analoji) ve somut örneklerle ele alacağız. Amacım ezberlemeniz değil, kalıcı olarak <em>anlamanız</em>.</p>
                    <p>Hazırsanız, optimizasyon dünyasına ilk adımımızı atalım.</p>
                    
                    <hr class="my-6">

                    <h2>Bölüm 1: Optimizasyona Giriş</h2>
                    
                    <h3>1. Nedir ve Neden Önemlidir?</h3>
                    <p>Optimizasyon, en basit tanımıyla, belirli kısıtlar altında mevcut seçenekler arasından <em>en iyi</em> sonucu bulma sanatıdır.</p>
                    <p>Hepimiz bunu günlük hayatta yaparız. Örneğin, bir kek tarifi düşünün. Amacınız, <em>en lezzetli</em> keki yapmaktır (bu sizin "en iyi" tanımınızdır). Ancak kısıtlarınız vardır: Evde sadece 2 yumurta kalmış (kaynak kısıtı) ve kekin toplam şekeri 100 gramı geçmemeli (sağlık kısıtı). İşte optimizasyon, bu kısıtlara uyarak lezzeti <em>maksimize</em> edecek un, şeker, yumurta oranını bulma işlemidir.</p>
                    <p>Mühendislikte bu, "en düşük maliyetle en sağlam köprüyü tasarlamak" veya "en kısa sürede en çok noktaya teslimat yapmak" (Gezgin Satıcı Problemi) olabilir.</p>

                    <h3>2. Nasıl Çalışır? (Temel Mantık ve Analojiler)</h3>
                    <p>Optimizasyonun temelinde iki ana bileşen yatar:</p>
                    <ol>
                        <li><strong>Amaç Fonksiyonu (Objective Function):</strong> Bu, "en iyi" olanı tanımlayan matematiksel bir formüldür. Kek örneğinde bu, "Lezzet Puanı"dır. Bir köprü tasarımında "Maliyet" (bunu <em>minimize</em> etmek isteriz) veya "Taşıma Kapasitesi" (bunu <em>maksimize</em> etmek isteriz) olabilir.</li>
                        <li><strong>Kısıtlar (Constraints):</strong> Bunlar, uymak zorunda olduğumuz kurallardır. Kek için <code>yumurta &lt;= 2</code> veya köprü için <code>kullanılan_çelik &lt;= 1000 ton</code> gibi.</li>
                    </ol>

                    <h4>Lokal ve Global Optimum (Dağ Manzarası Analojisi):</h4>
                    <img src="https://placehold.co/800x300/f5f5f4/a8a29e?text=Dağ+Manzarası+Analojisi+(Birden+Fazla+Zirve)" alt="Dağ Manzarası Analojisi" class="rounded-lg shadow-md w-full">
                    <p>Bir optimizasyon problemini, sisli bir dağ manzarası olarak hayal edin. Amacınız, bu manzaradaki <em>en yüksek</em> zirveye (Global Optimum) ulaşmaktır.</p>
                    <ul>
                        <li><strong>Lokal Optimum:</strong> Tırmanışa başladınız ve bir tepeye ulaştınız. Etrafınıza baktığınızda, indiğiniz her yön sizden daha alçakta kalıyor. "Zirvedeyim!" dersiniz. Ancak sis kalktığında, sizden çok daha yüksek olan Everest'i (Global Optimum) görürsünüz. Bulunduğunuz yer, sadece <em>kendi çevresindeki</em> en yüksek yerdi (Lokal Optimum).</li>
                        <li><strong>Global Optimum:</strong> Manzaradaki <em>mutlak</em> en yüksek noktadır.</li>
                    </ul>

                    <h4>Klasik vs. Sezgisel Optimizasyon:</h4>
                    <ul>
                        <li><strong>Klasik Optimizasyon (Türev Yöntemleri):</strong> Eğer dağın yüzeyi pürüzsüz ve matematiksel bir formülü (eğimi) biliniyorsa, türev (eğim) alarak zirveye giden yolu doğrudan hesaplayabilirsiniz.</li>
                        <li><strong>Sezgisel/Meta-sezgisel Optimizasyon:</strong> Eğer manzara çok karmaşıksa (kayalıklar, ormanlar, birçok farklı tepe) ve net bir formül yoksa, klasik yöntemler işe yaramaz. İşte burada <em>sezgisel</em> yöntemler devreye girer. Bunlar, "deneme-yanılma", "doğadan ilham alma" (kuş sürüleri, karınca kolonileri gibi) veya "rastgelelik" kullanarak en iyi zirveyi <em>keşfetmeye</em> çalışan akıllı arama stratejileridir. Genetik Algoritmalar, bu keşif yöntemlerinin en ünlülerinden biridir.</li>
                    </ul>

                    <h3>4. Profesörün Notu (Özet ve Püf Noktaları)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>Bir optimizasyon problemindeki en zor adım, algoritmayı çalıştırmak değil, problemi <em>doğru tanımlamaktır</em>. Eğer amaç fonksiyonunuz "en iyiyi" yanlış tanımlarsa, bulacağınız sonuç da yanlış olacaktır. Probleme "Ne istiyorum?" (Amaç) ve "Neye mecburum?" (Kısıtlar) sorularını sormak, çözümün %90'ıdır.</p>
                    </div>
                </section>

                <!-- BÖLÜM 2: GA (Gizli) -->
                <section id="bölüm2" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700 hidden">
                    <h2>Bölüm 2: Genetik Algoritma (GA)</h2>

                    <h3>1. Nedir ve Neden Önemlidir?</h3>
                    <p>Genetik Algoritmalar (GA), Charles Darwin'in "doğal seçilim" ve "en güçlünün hayatta kalması" (survival of the fittest) teorilerinden ilham alan meta-sezgisel bir optimizasyon yöntemidir. Karmaşık problemler için "yeterince iyi" çözümleri, evrimsel bir süreci taklit ederek bulur.</p>

                    <h3>2. Nasıl Çalışır? (Temel Mantık ve Analojiler)</h3>
                    <p>GA'yı, <em>en hızlı yarış atlarını</em> yetiştirmeye çalışan bir çiftlik sahibi gibi düşünün.</p>
                    
                    <h4>1. Terminoloji (At Çiftliği Analojisi):</h4>
                    <ul>
                        <li><strong>Problem:</strong> En hızlı yarış atını yetiştirmek.</li>
                        <li><strong>Popülasyon:</strong> Çiftlikteki tüm atlar sürüsü (probleme ait bir grup potansiyel çözüm).</li>
                        <li><strong>Kromozom:</strong> Tek bir at (potansiyel bir çözüm).</li>
                        <li><strong>Gen:</strong> Atın özellikleri (hız, dayanıklılık, bacak uzunluğu...). Problemin çözümündeki küçük parçalar.</li>
                        <li><strong>Fitness (Uygunluk):</strong> Atın yarışı ne kadar hızlı bitirdiği (çözümün ne kadar iyi olduğu).</li>
                    </ul>

                    <h4>2. Bir Genetik Algoritmanın Akış Şeması:</h4>
                    <ol>
                        <li><strong>Adım 1: Başlangıç Popülasyonu (Initialization):</strong> Çiftliğe rastgele özelliklerde 100 at (çözüm) alırsınız.</li>
                        <li><strong>Adım 2: Uygunluk Değerlendirmesi (Fitness Evaluation):</strong> Tüm atları yarıştırır ve her birinin hızını (uygunluğunu) ölçersiniz.</li>
                        <li><strong>Adım 3: Seçilim (Selection):</strong> En hızlı atların (en iyi çözümlerin) bir sonraki nesil için "ebeveyn" olmasına karar verirsiniz. (Bkz. Bölüm 3)</li>
                        <li><strong>Adım 4: Çaprazlama (Crossover):</strong> Seçilen ebeveynleri (hızlı atları) birbiriyle çiftleştirerek yeni "taylar" (yeni çözümler) yaratırsınız. Umudunuz, iki hızlı atın genlerinin birleşmesinin <em>daha da hızlı</em> bir tay yaratmasıdır. (Bkz. Bölüm 4)</li>
                        <li><strong>Adım 5: Mutasyon (Mutation):</strong> Yeni doğan taylarda <em>küçük, rastgele değişiklikler</em> yaparsınız (örn. bir genini hafifçe değiştirmek). Bu, sürpriz bir şekilde çok daha hızlı bir at yaratabilir ve genetik çeşitliliği korur.</li>
                        <li><strong>Adım 6: Yeni Nesil:</strong> Yeni doğan taylar, eski (ve daha yavaş olan) popülasyonun yerini alır. Artık yeni bir at sürünüz var.</li>
                        <li><strong>Adım 7: Durma Koşulu:</strong> Bu süreci (Adım 2'den 6'ya) 100 nesil boyunca veya "yeterince hızlı" bir at bulana kadar tekrarlarsınız.</li>
                    </ol>
                    
                    <h3>4. Profesörün Notu (Özet ve Püf Noktaları)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>Genetik Algoritmalar, problemin matematiksel türevini veya karmaşık yapısını bilmek zorunda değildir. Sadece bir çözümün "ne kadar iyi" olduğunu (fitness) ölçen bir fonksiyona ihtiyaç duyar. Bu yüzden "kara kutu" (black-box) optimizasyonunda çok güçlüdürler.</p>
                    </div>
                </section>

                <!-- BÖLÜM 3: SEÇİLİM (Gizli) -->
                <section id="bölüm3" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700 hidden">
                    <h2>Bölüm 3: GA Bileşenleri - Seçilim (Selection)</h2>

                    <h3>1. Nedir ve Neden Önemlidir?</h3>
                    <p>Seçilim, popülasyondaki bireyler arasından hangilerinin "ebeveyn" olup bir sonraki nesli yaratacağına karar verme sürecidir. Amaç, daha iyi (daha yüksek uygunluğa sahip) bireylerin genlerini bir sonraki nesle aktarma şansını artırmaktır.</p>

                    <h3>2. Nasıl Çalışır? (Rulet Yöntemi)</h3>
                    <p>En popüler seçilim yöntemlerinden biri <strong>Rulet Yöntemi (Roulette Wheel Selection)</strong>'dir.</p>
                    <p><strong>Analoji:</strong> Bir kumarhane ruleti düşünün. Ancak bu ruletteki her dilimin boyutu eşit değildir. Her bireyin (çözümün) dilim boyutu, onun <em>uygunluk puanı</em> ile orantılıdır.</p>
                    <p>Çok "fit" (başarılı) olan bir birey, rulette devasa bir dilime sahip olur. "Zayıf" bir birey ise küçücük bir dilime. Ruleti çevirdiğimizde, topun büyük dilimlere düşme olasılığı çok daha yüksektir, ancak <em>küçük dilimlere düşme şansı sıfır değildir</em>.</p>
                    <p>Bu önemlidir! Sadece en iyileri seçersek (elitizm), genetik çeşitliliği kaybeder ve bir lokal optimuma (Bölüm 1) takılabiliriz. Zayıf çözümlerin bile bazen değerli (ve gelecekte işe yarayacak) genetik materyaller taşıyabileceği fikrine dayanır.</p>

                    <h3>3. Adım Adım Detaylı Örnek ve Uygulama</h3>
                    <h4>Sayısal Örnek (Rulet Çarkı):</h4>
                    <p>Diyelim ki 4 kromozomdan (çözümden) oluşan bir popülasyonumuz var ve uygunluklarını (fitness) hesapladık (Amaç: Maksimizasyon):</p>
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th class="text-left">Kromozom</th>
                                <th class="text-left">Uygunluk Puanı</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>A</td><td>30</td></tr>
                            <tr><td>B</td><td>50</td></tr>
                            <tr><td>C</td><td>10</td></tr>
                            <tr><td>D</td><td>10</td></tr>
                        </tbody>
                    </table>

                    <p><strong>Adım 1: Toplam Uygunluğu Hesapla</strong><br>
                    <code>Toplam Uygunluk = 30 + 50 + 10 + 10 = 100</code></p>

                    <p><strong>Adım 2: Her Bireyin Seçilme Olasılığını (Rulet Dilimini) Hesapla</strong></p>
                    <ul>
                        <li>A'nın Olasılığı: <code>30 / 100 = 0.30</code> (%30)</li>
                        <li>B'nin Olasılığı: <code>50 / 100 = 0.50</code> (%50)</li>
                        <li>C'nin Olasılığı: <code>10 / 100 = 0.10</code> (%10)</li>
                        <li>D'nin Olasılığı: <code>10 / 100 = 0.10</code> (%10)</li>
                    </ul>

                    <p><strong>Adım 3: Kümülatif (Toplamalı) Olasılığı Hesapla</strong><br>
                    Bu, rulet dilimlerini uç uca eklemektir.</p>
                    <ul>
                        <li>A: 0.00 - 0.30 (aralığı)</li>
                        <li>B: 0.30 - 0.80 (yani 0.30 + 0.50)</li>
                        <li>C: 0.80 - 0.90 (yani 0.80 + 0.10)</li>
                        <li>D: 0.90 - 1.00 (yani 0.90 + 0.10)</li>
                    </ul>

                    <p><strong>Adım 4: Ruleti Çevir (Rastgele Sayı Üret)</strong><br>
                    İki ebeveyn seçmemiz gerekiyor. 0 ile 1 arasında iki kez rastgele sayı üretiyoruz.</p>
                    <ul>
                        <li><strong>1. Çeviriş:</strong> Rastgele sayı <code>0.45</code> geldi.
                            <ul><li>Bu sayı hangi aralıkta? <code>0.30 - 0.80</code> aralığında.</li>
                            <li><strong>Ebeveyn 1 olarak KROMOZOM B seçildi.</strong></li></ul>
                        </li>
                        <li><strong>2. Çeviriş:</strong> Rastgele sayı <code>0.82</code> geldi.
                            <ul><li>Bu sayı hangi aralıkta? <code>0.80 - 0.90</code> aralığında.</li>
                            <li><strong>Ebeveyn 2 olarak KROMOZOM C seçildi.</strong></li></ul>
                        </li>
                    </ul>
                    <p>Gördüğünüz gibi, en güçlü olan B'nin seçilme şansı yüksekti ve seçildi. Ama zayıf olan C de bir şans yakaladı.</p>

                    <h4>Sözde-Kod (Pseudo-code):</h4>
                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-pseudo-roulette">Sözde Kodu Göster/Gizle</button>
                    <div id="code-pseudo-roulette" class="code-container hidden">
<pre><code class="language-plaintext bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">FONKSİYON RuletSeçimi(popülasyon, uygunluk_puanları):
  // Adım 1: Toplamı al
  toplam_uygunluk = HEPSİNİ_TOPLA(uygunluk_puanları)
  
  // Adım 2 & 3: Kümülatif olasılıkları hesapla
  kümülatif_olasılıklar = []
  mevcut_toplam = 0
  DÖNGÜ her puan İÇİN uygunluk_puanları:
    normalize_edilmiş = puan / toplam_uygunluk
    mevcut_toplam = mevcut_toplam + normalize_edilmiş
    kümülatif_olasılıklar.EKLE(mevcut_toplam)
  
  // Adım 4: Ebeveynleri seç
  ebeveyn1 = SEÇ(popülasyon, kümülatif_olasılıklar)
  ebeveyn2 = SEÇ(popülasyon, kümülatif_olasılıklar)
  
  DÖNDÜR ebeveyn1, ebeveyn2

FONKSİYON SEÇ(popülasyon, kümülatif_olasılıklar):
  rastgele_sayı = RASTGELE(0, 1)
  DÖNGÜ i = 0'DAN popülasyon_boyutu'na:
    EĞER rastgele_sayı <= kümülatif_olasılıklar[i]:
      DÖNDÜR popülasyon[i]
</code></pre>
                    </div>

                    <h4>Python Kodu (Yorumlu):</h4>
                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-roulette">Python Kodunu Göster/Gizle</button>
                    <div id="code-python-roulette" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random
import numpy as np # numpy, kümülatif toplamlar için çok kullanışlıdır

def roulette_wheel_selection(population, fitness_scores):
    """
    Popülasyondan Rulet Yöntemi ile iki ebeveyn seçer.
    
    Args:
      population (list): Potansiyel çözümlerin (kromozomların) listesi.
      fitness_scores (list): Her kromozomun uygunluk puanı listesi.
      
    Returns:
      tuple: (ebeveyn1, ebeveyn2)
    """
    
    # Adım 1: Toplam uygunluğu hesapla
    total_fitness = sum(fitness_scores)
    
    # Adım 2: Her birinin seçilme olasılığını hesapla
    probabilities = [score / total_fitness for score in fitness_scores]
    
    # Adım 3: Kümülatif olasılıkları hesapla
    # np.cumsum([0.1, 0.3, 0.6]) -> [0.1, 0.4, 1.0]
    cumulative_probabilities = np.cumsum(probabilities)
    
    # Ebeveynleri seçecek yardımcı fonksiyon
    def select_one(population, cumulative_probabilities):
        # Adım 4: 0 ile 1 arasında rastgele bir sayı üret
        random_pick = random.random() # Örn: 0.45
        
        # Bu sayının hangi dilime düştüğünü bul
        for i, cum_prob in enumerate(cumulative_probabilities):
            if random_pick <= cum_prob:
                return population[i] # O kromozomu döndür
        
        # (Çok küçük olasılıkla) en sonuncuyu döndür
        return population[-1]

    # Adım 4 (Devamı): İki ebeveyni seç
    parent1 = select_one(population, cumulative_probabilities)
    parent2 = select_one(population, cumulative_probabilities)
    
    return parent1, parent2

# --- Örnek Kullanım ---
# Bölüm 3'teki sayısal örnek
population_list = ['A', 'B', 'C', 'D']
fitness_list = [30, 50, 10, 10]

# Fonksiyonu çağır
selected_parent1, selected_parent2 = roulette_wheel_selection(population_list, fitness_list)

print(f"Popülasyon: {population_list}")
print(f"Uygunluklar: {fitness_list}")
print(f"Seçilen Ebeveyn 1: {selected_parent1}")
print(f"Seçilen Ebeveyn 2: {selected_parent2}")
</code></pre>
                    </div>

                    <h3>4. Profesörün Notu (Özet ve Püf Noktaları)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>Rulet yönteminin en büyük avantajı, stokastik (rastgeleliğe dayalı) olmasıdır. "En iyi" olanın seçileceğini garanti etmez, sadece "şansını" artırır. Bu rastgelelik, algoritmanın yeni ve beklenmedik çözüm yollarını <em>keşfetmesi</em> için hayati önem taşır.</p>
                    </div>
                </section>

                <!-- BÖLÜM 4: ÇAPRAZLAMA (Gizli) -->
                <section id="bölüm4" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700 hidden">
                    <h2>Bölüm 4: GA Bileşenleri - Çaprazlama (Crossover)</h2>

                    <h3>1. Nedir ve Neden Önemlidir?</h3>
                    <p>Çaprazlama, GA'nın "yeni fikirler" ürettiği yerdir. Seçilen iki ebeveynin genetik materyalini (kromozomlarını) birleştirerek bir veya iki yeni "çocuk" (offspring) çözüm yaratma işlemidir.</p>
                    <p>Amaç: <strong>Keşif (Exploration)</strong>. Yani, çözüm uzayının (o dağ manzarasının) ebeveynlerin bulunduğu bölgelerden farklı, yeni bölgelerini keşfetmektir.</p>

                    <h3>2. Nasıl Çalışır? (Binary Çaprazlama Yöntemleri)</h3>
                    <p>En basit haliyle, çözümlerin <code>0</code> ve <code>1</code>'lerden oluşan ikili (binary) diziler olduğunu varsayalım.</p>
                    <ul>
                        <li><code>Ebeveyn 1 (P1): [1, 1, 1, 1, 1, 1, 1, 1]</code></li>
                        <li><code>Ebeveyn 2 (P2): [0, 0, 0, 0, 0, 0, 0, 0]</code></li>
                    </ul>

                    <h3>3. Adım Adım Detaylı Örnek ve Uygulama</h3>
                    
                    <h4>Yöntem 1: Tek Noktalı Çaprazlama (Single-Point Crossover)</h4>
                    <p>En basit yöntemdir. Kromozom üzerinde rastgele <em>tek bir kesme noktası</em> belirlenir.</p>
                    <ul>
                        <li><strong>Örnek:</strong> Kesme noktası 4 olsun.<br>
                        <code>P1 = [1, 1, 1, 1 | 1, 1, 1, 1]</code><br>
                        <code>P2 = [0, 0, 0, 0 | 0, 0, 0, 0]</code></li>
                        <li><strong>Çocuk 1 (C1):</strong> P1'in <em>ilk yarısını</em> ve P2'nin <em>ikinci yarısını</em> alır.<br>
                        <code>C1 = [1, 1, 1, 1, 0, 0, 0, 0]</code></li>
                        <li><strong>Çocuk 2 (C2):</strong> P2'nin <em>ilk yarısını</em> ve P1'in <em>ikinci yarısını</em> alır.<br>
                        <code>C2 = [0, 0, 0, 0, 1, 1, 1, 1]</code></li>
                    </ul>
                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-single-point">Python Kodunu Göster/Gizle</button>
                    <div id="code-python-single-point" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random

def single_point_crossover(parent1, parent2):
    # Kromozom uzunluğunu al (ebeveynlerin eşit uzunlukta olduğunu varsay)
    length = len(parent1)
    
    # 1 ile (length - 1) arasında rastgele bir kesme noktası seç
    crossover_point = random.randint(1, length - 1)
    
    print(f"Kesme Noktası: {crossover_point}")
    
    # Çocuk 1: P1'in başı + P2'nin sonu
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    
    # Çocuk 2: P2'nin başı + P1'in sonu
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    
    return child1, child2

# --- Örnek Kullanım ---
p1 = [1, 1, 1, 1, 1, 1, 1, 1]
p2 = [0, 0, 0, 0, 0, 0, 0, 0]
c1, c2 = single_point_crossover(p1, p2)
print(f"P1: {p1}\nP2: {p2}\nC1: {c1}\nC2: {c2}")
</code></pre>
                    </div>

                    <h4>Yöntem 2: Çok Noktalı Çaprazlama (Multi-Point Crossover)</h4>
                    <p>Tek nokta yerine, <em>birden fazla</em> (genellikle iki) kesme noktası belirlenir. Bu, genetik materyalin daha fazla karışmasını sağlar.</p>
                    <ul>
                        <li><strong>Örnek:</strong> Kesme noktaları 2 ve 6 olsun.<br>
                        <code>P1 = [1, 1 | 1, 1, 1, 1 | 1, 1]</code><br>
                        <code>P2 = [0, 0 | 0, 0, 0, 0 | 0, 0]</code></li>
                        <li><strong>C1:</strong> P1 (baş) + P2 (orta) + P1 (son)<br>
                        <code>C1 = [1, 1, 0, 0, 0, 0, 1, 1]</code></li>
                        <li><strong>C2:</strong> P2 (baş) + P1 (orta) + P2 (son)<br>
                        <code>C2 = [0, 0, 1, 1, 1, 1, 0, 0]</code></li>
                    </ul>
                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-two-point">Python Kodunu Göster/Gizle</button>
                    <div id="code-python-two-point" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random

def two_point_crossover(parent1, parent2):
    length = len(parent1)
    
    # İki farklı kesme noktası seç
    point1 = random.randint(1, length - 2)
    point2 = random.randint(point1 + 1, length - 1)
    
    print(f"Kesme Noktaları: {point1} ve {point2}")
    
    # Çocuk 1: P1(baş) + P2(orta) + P1(son)
    child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:]
    
    # Çocuk 2: P2(baş) + P1(orta) + P2(son)
    child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]
    
    return child1, child2

# --- Örnek Kullanım ---
p1 = [1, 1, 1, 1, 1, 1, 1, 1]
p2 = [0, 0, 0, 0, 0, 0, 0, 0]
c1, c2 = two_point_crossover(p1, p2)
print(f"P1: {p1}\nP2: {p2}\nC1: {c1}\nC2: {c2}")
</code></pre>
                    </div>
                    
                    <h4>Yöntem 3: Üniform Çaprazlama (Uniform Crossover)</h4>
                    <p>En fazla karışıklığı sağlayan yöntemdir. Her bir <em>gen</em> için ayrı ayrı karar verilir.</p>
                    <ul>
                        <li><strong>Örnek:</strong> Rastgele bir "maske" (yazı-tura) oluşturulur.<br>
                        <code>Maske = [1, 0, 0, 1, 0, 1, 1, 0]</code></li>
                        <li><strong>Kural:</strong> Maskede <code>1</code> varsa, geni P1'den al. <code>0</code> varsa, geni P2'den al.<br>
                        <code>C1 = [1(P1), 0(P2), 0(P2), 1(P1), 0(P2), 1(P1), 1(P1), 0(P2)]</code><br>
                        <code>C1 = [1, 0, 0, 1, 0, 1, 1, 0]</code></li>
                        <li><strong>C2:</strong> Genellikle ters maske uygulanır. (0 ise P1'den, 1 ise P2'den).<br>
                        <code>C2 = [0, 1, 1, 0, 1, 0, 0, 1]</code></li>
                    </ul>
                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-uniform">Python Kodunu Göster/Gizle</button>
                    <div id="code-python-uniform" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random

def uniform_crossover(parent1, parent2):
    length = len(parent1)
    child1 = []
    child2 = []
    
    mask = [] # Sadece görselleştirme için
    
    # Her gen için bir yazı-tura at
    for i in range(length):
        # %50 olasılıkla (0.5) P1'den al
        if random.random() < 0.5:
            child1.append(parent1[i])
            child2.append(parent2[i])
            mask.append(1) # 1 = P1'den al
        else:
            child1.append(parent2[i])
            child2.append(parent1[i])
            mask.append(0) # 0 = P2'den al
            
    print(f"Rastgele Maske: {mask} (1=P1'den, 0=P2'den C1'e)")
    
    return child1, child2

# --- Örnek Kullanım ---
p1 = [1, 1, 1, 1, 1, 1, 1, 1]
p2 = [0, 0, 0, 0, 0, 0, 0, 0]
c1, c2 = uniform_crossover(p1, p2)
print(f"P1: {p1}\nP2: {p2}\nC1: {c1}\nC2: {c2}")
</code></pre>
                    </div>

                    <h3>4. Profesörün Notu (Özet ve Püf Noktaları)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>Çaprazlama yöntemi seçimi, problemin yapısına bağlıdır. Eğer genler arasında güçlü bir ilişki varsa (örn. yan yana olan genler bir anlam ifade ediyorsa), Tek Noktalı Çaprazlama bu "iyi gen bloklarını" (building blocks) korumaya yardımcı olur. Eğer her gen bağımsızsa, Üniform Çaprazlama daha iyi bir <em>keşif</em> sağlar.</p>
                    </div>
                </section>

                <!-- BÖLÜM 5: DE (Gizli) -->
                <section id="bölüm5" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700 hidden">
                    <h2>Bölüm 5: Diferansiyel Evrim (Differential Evolution - DE)</h2>
                    
                    <h3>1. Nedir ve Neden Önemlidir?</h3>
                    <p>Diferansiyel Evrim (DE), GA'ya benzeyen ancak özellikle <em>sürekli</em> (reel sayılı, örn. 1.234, -5.678) optimizasyon problemlerinde (örn. bir fonksiyonun minimumunu bulma, bir makinenin ayar parametrelerini optimize etme) olağanüstü başarı gösteren bir algoritmadır.</p>
                    
                    <h4>GA'dan Farkı Nedir?</h4>
                    <p>En temel fark "yeni çözüm üretme" (üreme) stratejisidir.</p>
                    <ul>
                        <li>GA, iki ebeveyni <em>birleştirerek</em> (çaprazlayarak) çocuk üretir.</li>
                        <li>DE, popülasyondaki diğer bireylerin <em>fark vektörlerini</em> (differential) kullanarak bir "mutant" vektör yaratır ve bunu mevcut ebeveynle birleştirir.</li>
                    </ul>
                    
                    <h3>2. Nasıl Çalışır? (Temel Mantık)</h3>
                    <p>DE'nin akışı da GA'ya benzer (Başlat, Değerlendir, Yeni Nesil Yarat, Tekrarla), ancak "Yeni Nesil Yarat" adımı (Mutasyon, Çaprazlama, Seçilim) çok farklıdır.</p>
                    <p>Popülasyondaki her "Hedef Vektör" (ebeveyn) <code>x</code> için:</p>
                    <ol>
                        <li><strong>Mutasyon (Farklı Bir Anlamda!):</strong>
                            <ul>
                                <li>Popülasyondan <code>x</code> <em>dışında</em> rastgele 3 birey seç: <code>a</code>, <code>b</code>, <code>c</code>.</li>
                                <li>Bir "fark vektörü" hesapla: <code>v_fark = b - c</code></li>
                                <li>Bu farkı ölçekle (bir <code>F</code> sabiti ile) ve <code>a</code>'ya ekle.</li>
                                <li><code>v_mutant = a + F * (b - c)</code></li>
                            </ul>
                        </li>
                        <li><strong>Çaprazlama (Recombination/Crossover):</strong>
                            <ul>
                                <li>Oluşan <code>v_mutant</code> ile <em>orijinal ebeveyn</em> (<code>x</code>) arasında bir tür üniform çaprazlama yapılır.</li>
                                <li>Bir "Çaprazlama Oranı" (CR, örn. 0.7) belirlenir.</li>
                                <li>Her gen (parametre) için 0-1 arası rastgele bir sayı üretilir.</li>
                                <li>Eğer <code>sayı < CR</code> ise, geni <code>v_mutant</code>'tan al.</li>
                                <li>Değilse, geni orijinal ebeveyn <code>x</code>'ten al.</li>
                                <li>Bunun sonucunda "Deneme Vektörü" (trial vector) <code>u</code> oluşur.</li>
                            </ul>
                        </li>
                        <li><strong>Seçilim (Selection):</strong>
                            <ul>
                                <li>Bu adım GA'dan çok daha basittir: <strong>Açgözlü (Greedy)</strong> bir seçim yapılır.</li>
                                <li>Oluşan yeni "Deneme Vektörü" <code>u</code>'nun uygunluğuna bak.</li>
                                <li>Orijinal ebeveyn <code>x</code>'in uygunluğuna bak.</li>
                                <li><strong>Hangisi daha iyiyse,</strong> o, yeni popülasyona <em>aynen</em> girer. Diğeri atılır.</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <h3>3. Adım Adım Detaylı Örnek ve Uygulama</h3>
                    <p><strong>Problem:</strong> <code>f(x, y) = x^2 + y^2</code> fonksiyonunu minimize edelim (Global optimum <code>x=0, y=0</code>'dadır ve sonuç <code>0</code>'dır).</p>
                    <p>Aşağıdaki Python kodu, Diferansiyel Evrim'in bu basit 2-boyutlu fonksiyon üzerinde nasıl çalıştığını gösterir.</p>

                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-de">Python Kodunu Göster/Gizle</button>
                    <div id="code-python-de" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random
import numpy as np

# --- 1. Problem Tanımı ---
# Minimize etmek istediğimiz amaç fonksiyonu
def objective_function(vector):
    # f(x, y) = x^2 + y^2
    # vector[0] = x, vector[1] = y
    return vector[0]**2 + vector[1]**2

# --- 2. DE Parametreleri ---
population_size = 20    # Popülasyondaki birey (çözüm adayı) sayısı
dimensions = 2          # Problemimizin boyutu (x ve y)
bounds = [(-5.0, 5.0), (-5.0, 5.0)] # Her boyut için arama sınırları
F = 0.8                 # Mutasyon faktörü (scaling factor)
CR = 0.7                # Çaprazlama oranı (crossover rate)
generations = 100       # Toplam nesil sayısı

# --- 3. Başlangıç Popülasyonu ---
population = []
for _ in range(population_size):
    random_vector = np.random.uniform(bounds[0][0], bounds[0][1], dimensions)
    population.append(random_vector)

population = np.array(population)

print("--- Başlangıç Popülasyonundan Örnekler ---")
print(population[:3])
print("-" * 30)

# --- 4. Evrim Süreci ---
for gen in range(generations):
    new_population = []
    
    for i in range(population_size):
        target_vector = population[i]
        
        # --- Adım 1: Mutasyon ---
        indices = [idx for idx in range(population_size) if idx != i]
        a, b, c = population[np.random.choice(indices, 3, replace=False)]
        
        mutant_vector = a + F * (b - c)
        mutant_vector = np.clip(mutant_vector, bounds[0][0], bounds[0][1])

        # --- Adım 2: Çaprazlama ---
        trial_vector = np.copy(target_vector)
        j_rand = random.randrange(dimensions) 
        
        for j in range(dimensions):
            if random.random() < CR or j == j_rand:
                trial_vector[j] = mutant_vector[j]
        
        # --- Adım 3: Seçilim ---
        target_fitness = objective_function(target_vector)
        trial_fitness = objective_function(trial_vector)
        
        if trial_fitness < target_fitness:
            new_population.append(trial_vector)
        else:
            new_population.append(target_vector)
            
    population = np.array(new_population)

# --- 5. Sonuç ---
best_fitness = float('inf')
best_vector = None
for vector in population:
    fitness = objective_function(vector)
    if fitness < best_fitness:
        best_fitness = fitness
        best_vector = vector

print(f"--- {generations} Nesil Sonrası ---")
print(f"Bulunan En İyi Çözüm (x, y): {best_vector}")
print(f"Bulunan En İyi Uygunluk (x^2 + y^2): {best_fitness}")
</code></pre>
                    </div>

                    <h3>4. Profesörün Notu (Özet ve Püf Noktaları)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>DE'nin gücü, arama yönünü (fark vektörünü) popülasyonun kendisine göre <em>otomatik</em> olarak ayarlamasından gelir. Eğer popülasyon çok dağılmışsa (b, c arası fark büyükse), büyük adımlar atar (keşif). Eğer popülasyon bir optimuma yakınsamışsa (b, c arası fark küçükse), küçük adımlar atar (ince ayar - exploitation). Bu "kendi kendine yeten" (self-adapting) doğası, onu çok güçlü bir algoritma yapar.</p>
                    </div>
                </section>

                <!-- BÖLÜM 6: UYGULAMALAR (Gizli) -->
                <section id="bölüm6" class="content-section prose prose-stone max-w-none prose-h2:font-serif prose-h2:text-amber-800 prose-h2:border-b prose-h2:pb-2 prose-h3:font-serif prose-h3:text-amber-700 hidden">
                    <h2>Bölüm 6: Uygulama Örnekleri (Klasik Problemler)</h2>
                    
                    <h3>Bölüm 6.1: 8-Vezir Problemi</h3>
                    
                    <h4>1. Nedir ve Neden Önemlidir?</h4>
                    <p>8-Vezir problemi, klasik bir kısıt karşılama problemidir. Amaç, 8x8 bir satranç tahtasına 8 veziri, <em>hiçbiri birbirini tehdit etmeyecek</em> şekilde yerleştirmektir. Yani, hiçbir iki vezir aynı <em>satırda</em>, aynı <em>sütunda</em> veya aynı <em>çaprazda</em> olmamalıdır.</p>
                    <img src="https://placehold.co/600x400/f5f5f4/a8a29e?text=8-Vezir+Problemi+Çözümü" alt="8-Vezir Problemi Çözümü" class="rounded-lg shadow-md w-full max-w-md mx-auto">
                    <p>Bu problem, GA'nın "Temsil (Representation)" ve "Uygunluk Fonksiyonu (Fitness Function)" tasarımının ne kadar kritik olduğunu göstermek için harika bir örnektir.</p>
                    
                    <h4>3. Adım Adım Detaylı Uygulama (GA ile)</h4>
                    
                    <p><strong>Kromozom Temsili (Representation):</strong><br>
                    <em>Akıllı Temsil:</em> "Her sütunda tam olarak bir vezir" olacağını varsayalım. O halde, kromozomumuz 8 uzunluğunda bir tamsayı listesi olur.<br>
                    <code>Kromozom[i] = j</code> demek: <strong>"i. Sütundaki vezir, j. Satırdadır."</strong></p>
                    <ul>
                        <li><strong>Örnek Kromozom:</strong> <code>[4, 6, 0, 3, 1, 7, 5, 2]</code></li>
                        <li><strong>Anlamı:</strong> Sütun 0'daki vezir -> Satır 4'te, Sütun 1'deki vezir -> Satır 6'da...</li>
                    </ul>
                    <p>Bu temsil ile "sütun çakışmalarını" otomatik olarak <em>önlemiş</em> olduk!</p>

                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-8q-rep">Python (Temsil) Kodunu Göster/Gizle</button>
                    <div id="code-python-8q-rep" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">import random

def create_random_chromosome():
    """
    Her sütunda bir vezir olacak şekilde rastgele bir dizilim oluşturur.
    """
    chromosome = [random.randint(0, 7) for _ in range(8)]
    return chromosome

example_chromosome = create_random_chromosome()
print(f"Örnek 8-Vezir Kromozomu: {example_chromosome}")
print(f"Anlamı: Sütun 0'da vezir {example_chromosome[0]}. satırda.")
</code></pre>
                    </div>

                    <p><strong>Uygunluk Fonksiyonu (Fitness Function):</strong><br>
                    Amacımız "tehdit sayısını" <em>minimize</em> etmektir. Mükemmel bir çözümün fitness (hata) puanı <code>0</code> olmalıdır.</p>
                    <ol>
                        <li><strong>Satır Tehditleri:</strong> Kromozom listesinde <em>tekrarlayan sayıların</em> olması demektir.</li>
                        <li><strong>Çapraz Tehditler:</strong> Eğer <code>abs(sütun_i - sütun_j) == abs(satır_i - satır_j)</code> ise, bu bir tehdittir.</li>
                    </ol>

                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-8q-fit">Python (Uygunluk) Kodunu Göster/Gizle</button>
                    <div id="code-python-8q-fit" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto">def calculate_fitness(chromosome):
    """
    Bir 8-Vezir kromozomunun uygunluğunu (tehdit sayısını) hesaplar.
    Amaç: Bu değeri 0'a (minimize) indirmek.
    """
    
    clashes = 0 # Toplam tehdit sayısı
    n = len(chromosome) # n = 8
    
    # 1. Satır Tehditlerini Hesapla
    row_clashes = abs(len(chromosome) - len(set(chromosome)))
    clashes += row_clashes

    # 2. Çapraz Tehditlerini Hesapla
    for i in range(n):
        for j in range(i + 1, n):
            col_diff = abs(i - j)
            row_diff = abs(chromosome[i] - chromosome[j])
            
            if col_diff == row_diff:
                clashes += 1
                
    return clashes

# --- Örnek Kullanım ---
bad_solution = [0, 1, 2, 3, 4, 5, 6, 7]
print(f"Kötü Çözüm: {bad_solution}")
print(f"Tehdit Sayısı: {calculate_fitness(bad_solution)}") # Çıktı: 28

perfect_solution = [4, 6, 0, 3, 1, 7, 5, 2]
print(f"Mükemmel Çözüm: {perfect_solution}")
print(f"Tehdit Sayısı: {calculate_fitness(perfect_solution)}") # Çıktı: 0
</code></pre>
                    </div>

                    <hr class="my-8">

                    <h3>Bölüm 6.2: Bin-Packing (Kutu Paketleme) Problemi</h3>
                    
                    <h4>1. Nedir ve Neden Önemlidir?</h4>
                    <p>1D Bin-Packing (1 Boyutlu Kutu Paketleme), NP-Hard (hesaplanması zor) klasik bir optimizasyon problemidir.</p>
                    <p><strong>Problem:</strong> Elimizde farklı ağırlıklarda bir dizi eşya var. Hepsinin <em>aynı</em> kapasiteye sahip olduğu sınırsız sayıda kutumuz var. Amaç: Tüm eşyaları, <em>minimum sayıda kutu* kullanarak paketlemek.</p>
                    <ul>
                        <li><strong>Eşyalar (ağırlıklar):</strong> <code>[7, 1, 4, 3, 5, 2]</code></li>
                        <li><strong>Kutu Kapasitesi:</strong> <code>10</code></li>
                    </ul>

                    <h4>3. Adım Adım Detaylı Uygulama (GA ile)</h4>
                    <p><strong>Kromozom Temsili (Representation):</strong><br>
                    Kromozom, <em>eşya sayısı* kadar uzunluğa sahip bir listedir.<br>
                    <code>Kromozom[i] = k</code> demek: <strong>"i. Eşya, k. Kutuya yerleştirildi."</strong></p>
                    <ul>
                        <li><strong>Örnek Kromozom:</strong> <code>[0, 1, 0, 2, 2, 1]</code></li>
                        <li><strong>Anlamı:</strong> Eşya 0 (7kg) -> Kutu 0, Eşya 1 (1kg) -> Kutu 1, Eşya 2 (4kg) -> Kutu 0...</li>
                    </ul>

                    <p><strong>Amaç Fonksiyonu (Fitness Function):</strong><br>
                    Amacımız "kullanılan kutu sayısını" <em>minimize* etmektir. En önemli kısıt: Hiçbir kutu kapasitesini aşamaz!</p>
                    <ol>
                        <li><strong>Geçerlilik Kontrolü:</strong> Kutu 0: 7kg + 4kg = 11kg. -> <strong>KAPASİTEYİ AŞTI! (10kg)</strong></li>
                        <li><strong>Ceza (Penalty):</strong> Geçersiz çözümlere <em>çok yüksek</em> bir hata (fitness) puanı (örn. 99999) verilir.</li>
                        <li><strong>Geçerli Çözümün Hesaplanması:</strong> Geçerliyse, fitness = kullanılan toplam kutu sayısı (<code>len(set(kromozom))</code>).</li>
                    </ol>

                    <button class="toggle-code my-2 px-4 py-2 bg-stone-200 text-stone-800 rounded-lg hover:bg-stone-300 transition-colors text-sm font-medium" data-target="code-python-binpack">Python (Uygunluk) Kodunu Göster/Gizle</button>
                    <div id="code-python-binpack" class="code-container hidden">
<pre><code class="language-python bg-gray-900 text-gray-200 p-4 rounded-lg block overflow-x-auto"># Problem tanımı
items = [7, 1, 4, 3, 5, 2] # Eşyaların ağırlıkları
bin_capacity = 10         # Her kutunun maksimum kapasitesi
num_items = len(items)
max_bins = num_items 

def calculate_bin_packing_fitness(chromosome):
    """
    Bir bin-packing kromozomunun uygunluğunu (kutu sayısı) hesaplar.
    Geçersizse (kapasite aşımı) çok yüksek ceza verir.
    """
    
    bins = {} # {kutu_numarası: toplam_ağırlık}
    
    for i in range(len(chromosome)):
        item_weight = items[i]
        bin_index = chromosome[i]
        
        if bin_index not in bins:
            bins[bin_index] = 0
        bins[bin_index] += item_weight

    # 2. Geçerliliği Kontrol Et (Ceza)
    for bin_index in bins:
        if bins[bin_index] > bin_capacity:
            penalty = 99999 * (bins[bin_index] - bin_capacity)
            return len(bins) + penalty # Veya sadece 99999

    # 3. Geçerliyse Fitness'ı Hesapla
    fitness = len(bins)
    return fitness

# --- Örnek Kullanım ---
invalid_solution = [0, 1, 0, 2, 2, 1]
print(f"Geçersiz Çözüm: {invalid_solution}")
print(f"Fitness (Hata): {calculate_bin_packing_fitness(invalid_solution)}")

optimal_solution_3 = [0, 1, 1, 2, 2, 1]
print(f"Optimal Çözüm (3 Kutu): {optimal_solution_3}")
print(f"Fitness (Kutu Sayısı): {calculate_bin_packing_fitness(optimal_solution_3)}")
</code></pre>
                    </div>

                    <hr class="my-8">

                    <h3>4. Profesörün Notu (Bölüm 6 için Genel Not)</h3>
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-4 rounded-r-lg">
                        <p class="font-semibold text-amber-800">Profesörün Notu</p>
                        <p>Sevgili öğrencilerim, son iki örnekte (8-Vezir ve Bin-Packing) gördüğünüz gibi, Genetik Algoritmaların asıl dehası <code>seçilim</code> veya <code>çaprazlama</code> kodunda değildir. Asıl deha, sizin, yani mühendisin, karmaşık bir problemi GA'nın anlayabileceği basit bir <em>temsile</em> (kromozom) ve başarının ne olduğunu <em>ölçebileceği</em> bir <em>uygunluk fonksiyonuna</em> dökebilme becerinizdedir.</p>
                        <p>Problemi doğru temsil ederseniz, çözümün yarısını bulmuşsunuz demektir.</p>
                    </div>

                </section>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const navLinks = document.querySelectorAll('.nav-link');
            const contentSections = document.querySelectorAll('.content-section');
            const mobileMenuButton = document.getElementById('mobile-menu-button');
            const mobileMenu = document.getElementById('mobile-menu');

            // Gezinme (Navigasyon) Mantığı
            const handleNavClick = (e) => {
                e.preventDefault();
                const targetId = e.currentTarget.getAttribute('data-target');

                // Tüm içerik bölümlerini gizle
                contentSections.forEach(section => {
                    section.classList.add('hidden');
                });

                // Hedef bölümü göster
                const targetSection = document.getElementById(targetId);
                if (targetSection) {
                    targetSection.classList.remove('hidden');
                }

                // Tüm linklerdeki aktif durumunu kaldır
                navLinks.forEach(link => {
                    link.classList.remove('nav-active');
                });

                // Tıklanan linke (ve onunla aynı hedefi paylaşan diğer linke) aktif durumunu ekle
                navLinks.forEach(link => {
                    if (link.getAttribute('data-target') === targetId) {
                        link.classList.add('nav-active');
                    }
                });

                // Mobil menüyü kapat
                mobileMenu.classList.add('hidden');
                // Mobil menü iconunu sıfırla
                mobileMenuButton.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>`;

                // Sayfanın başına git
                window.scrollTo(0, 0);
            };

            navLinks.forEach(link => {
                link.addEventListener('click', handleNavClick);
            });

            // Mobil Menü Aç/Kapat
            mobileMenuButton.addEventListener('click', () => {
                const isHidden = mobileMenu.classList.toggle('hidden');
                if (isHidden) {
                    mobileMenuButton.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>`;
                } else {
                    mobileMenuButton.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
                }
            });

            // Kod Göster/Gizle Mantığı
            const toggleButtons = document.querySelectorAll('.toggle-code');
            toggleButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.getAttribute('data-target');
                    const codeContainer = document.getElementById(targetId);
                    
                    if (codeContainer) {
                        const isHidden = codeContainer.classList.toggle('hidden');
                        if (isHidden) {
                            button.textContent = button.textContent.replace('Gizle', 'Göster');
                        } else {
                            button.textContent = button.textContent.replace('Göster', 'Gizle');
                        }
                    }
                });
            });
        });
    </script>
</body>
</html>
